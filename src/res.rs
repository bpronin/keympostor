use native_windows_gui as nwg;
use std::cell::RefCell;
use std::sync::LazyLock;

pub(crate) mod res_ids; /* autogenerated */

#[macro_export]
macro_rules! rs {
    ($res_id:ident) => {
        &RESOURCES.string($res_id)
    };
}

#[macro_export]
macro_rules! r_icon {
    ($res_id:ident) => {
        &RESOURCES.icon($res_id)
    };
}

pub(crate) static RESOURCES: LazyLock<Resources> = LazyLock::new(|| Resources {});

pub(crate) struct Resources {}

impl Resources {
    thread_local! {
        static EMBED_RES: RefCell<nwg::EmbedResource> = RefCell::new(
            nwg::EmbedResource::load(None).expect("Unable to load embedded resources")
        )
    }

    pub(crate) fn icon(&self, res_id: usize) -> nwg::Icon {
        Self::EMBED_RES.with_borrow(|res| {
            let mut icon = nwg::Icon::default();

            nwg::Icon::builder()
                .source_embed(Some(res))
                .source_embed_id(res_id)
                .strict(true)
                .size(Some((16, 16)))
                .build(&mut icon)
                .expect("Unable to load resource icon");

            icon
        })
    }

    pub(crate) fn string(&self, res_id: usize) -> String {
        Self::EMBED_RES.with_borrow(|res| {
            res.string(res_id as u32)
                .expect("Unable to read resource string")
        })
    }
}

// #[cfg(test)]
// mod test {
//     use crate::res::SOUND_GAME_LOCK_OFF;
//     use crate::util::play_sound;
//
//     #[test]
//     fn test_play_sound() {
//         play_sound(SOUND_GAME_LOCK_OFF);
//     }
// }
