#![cfg_attr(not(feature = "dev"), windows_subsystem = "windows")]

extern crate native_windows_gui as nwg;

use crate::config::AppConfig;
use crate::key_hook::KeyboardHandler;
use crate::key_code::KeyCode;
use crate::res::RESOURCE_STRINGS;
use key_transition::KeyTransition;
use key_hook::KeyboardEvent;
use log::LevelFilter;
use nwg::{EmbedResource, NativeUi};
use simple_logger::SimpleLogger;
use std::cell::RefCell;
use std::error;
use crate::res_ids::{IDI_ICON_GAME_LOCK_OFF, IDI_ICON_GAME_LOCK_ON};

mod config;
mod key_action;
mod key_hook;
mod key_code;
mod key_modifier;
mod res;
mod res_ids; /* autogenerated */
mod transform;
mod ui;
mod util;
mod key_transition;

pub(crate) struct App {
    keyboard_handler: KeyboardHandler,
    resources: EmbedResource,
    window: nwg::Window,
    layout: nwg::FlexboxLayout,
    text_editor: nwg::TextInput,
    log_view: nwg::TextBox, //todo set log max capacity
    main_menu: MainMenu,
    tray: nwg::TrayNotification,
    tray_menu: TrayMenu,
}

#[derive(Default)]
struct MainMenu {
    menu: nwg::Menu,
    toggle_processing_enabled_item: nwg::MenuItem,
    toggle_logging_enabled_item: nwg::MenuItem,
    clear_log_item: nwg::MenuItem,
    separator: nwg::MenuSeparator,
    exit_app_item: nwg::MenuItem,
}

#[derive(Default)]
struct TrayMenu {
    menu: nwg::Menu,
    toggle_processing_enabled_item: nwg::MenuItem,
    open_app_item: nwg::MenuItem,
    exit_app_item: nwg::MenuItem,
    separator: nwg::MenuSeparator,
}

impl App {
    fn new() -> Self {
        let config = Self::load_config();
        let keyboard_handler = KeyboardHandler::from(config).unwrap_or_else(|e| {
            ui_panic!("Error creating keyboard handler.\n{}", e);
        });

        Self {
            keyboard_handler,
            resources: EmbedResource::load(None).unwrap(),
            window: Default::default(),
            layout: Default::default(),
            text_editor: Default::default(),
            log_view: Default::default(),
            main_menu: Default::default(),
            tray: Default::default(),
            tray_menu: Default::default(),
        }
    }

    fn load_config() -> AppConfig {
        AppConfig::load().unwrap_or_else(|e| {
            ui_panic!("{}", e);
        })
    }

    pub(crate) fn get_icon(&self, icon_id: usize) -> nwg::Icon {
        let mut icon = nwg::Icon::default();
        nwg::Icon::builder()
            .source_embed(Some(&self.resources))
            .source_embed_id(icon_id)
            .strict(true)
            .size(Some((16, 16)))
            .build(&mut icon)
            .unwrap_or_else(|e| {
                ui_panic!("{}", e);
            });
        icon
    }

    fn run(&self) {
        // let callback = |event: &KeyboardEvent| {self.on_log_view_update(event)};
        // let boxed_callback = Box::new(callback);

        let boxed_callback = Box::new(on_key_event);
        self.keyboard_handler.set_callback(Some(boxed_callback));

        self.update_controls();
        self.update_controls_logging_enabled();

        #[cfg(feature = "dev")]
        {
            self.log_view.appendln("--- Debug UI");
            self.log_view
                .appendln(format!("--- {}", &AppConfig::file_path()).as_str());
        }

        nwg::dispatch_thread_events();
    }

    fn update_controls(&self) {
        self.main_menu
            .toggle_processing_enabled_item
            .set_checked(self.keyboard_handler.is_enabled());

        self.main_menu
            .toggle_logging_enabled_item
            .set_checked(!self.keyboard_handler.is_silent());

        self.tray_menu
            .toggle_processing_enabled_item
            .set_checked(self.keyboard_handler.is_enabled());

        if self.keyboard_handler.is_enabled() {
            self.tray.set_icon(&self.get_icon(IDI_ICON_GAME_LOCK_ON));
        } else {
            self.tray.set_icon(&self.get_icon(IDI_ICON_GAME_LOCK_OFF));
        }
    }

    fn update_controls_logging_enabled(&self) {
        if self.keyboard_handler.is_silent() {
            self.log_view.appendln(rs!(_logging_disabled_));
        } else {
            self.log_view.appendln(rs!(_logging_enabled_));
        }
    }

    fn update_config(&self) {
        let mut config = Self::load_config();
        config.app_state.key_processing_enabled = self.keyboard_handler.is_enabled();
        config.save().unwrap_or_else(|e| {
            ui_warn!("Error saving configuration.{}", e);
        });
    }

    fn on_toggle_processing_enabled(&self) {
        self.keyboard_handler
            .set_enabled(!self.keyboard_handler.is_enabled());
        self.update_controls();
        self.update_config();
    }

    fn on_toggle_logging_enabled(&self) {
        self.keyboard_handler
            .set_silent(!self.keyboard_handler.is_silent());

        self.update_controls_logging_enabled();
        self.update_controls();
        self.update_config();
    }

    fn on_app_exit(&self) {
        nwg::stop_thread_dispatch();
    }

    fn on_window_close(&self) {
        #[cfg(feature = "dev")]
        self.on_app_exit();
    }

    fn on_open_window(&self) {
        self.window.set_visible(true);
    }

    fn on_toggle_window_visibility(&self) {
        self.window.set_visible(!self.window.visible());
    }

    fn on_tray_menu_show(&self) {
        let (x, y) = nwg::GlobalCursor::position();
        self.tray_menu.menu.popup(x, y);
    }

    fn on_log_view_clear(&self) {
        self.log_view.clear();
    }

    fn on_log_view_update(&self, event: &KeyboardEvent) {
        let action = event.action;
        let scancode = action.key.scancode.unwrap();
        let virtual_key = action.key.virtual_key.unwrap();
        let line = format!(
            "{}{}{} T: {} | {:20} [{}] | {:20} [{}] | {}",
            if event.is_processable() { "!" } else { " " },
            if event.is_injected() { ">" } else { " " },
            if event.is_private() { "X" } else { " " },
            event.time(),
            scancode.name(),
            scancode,
            virtual_key.name(),
            virtual_key,
            action.transition
        );

        self.log_view.appendln(line.as_str());
    }
}

thread_local! {
    static APP: RefCell<ui::AppUi> = RefCell::new(
        App::build_ui(App::new()).expect("Failed to build application UI")
    )
}

// todo: get rid of it
fn on_key_event(event: &KeyboardEvent) {
    APP.with_borrow(|app| app.on_log_view_update(event))
}

fn main() -> Result<(), Box<dyn error::Error>> {
    SimpleLogger::new().with_level(LevelFilter::Debug).init()?;
    APP.with_borrow(|app| app.run());
    Ok(())
}
