use error::Error;
use log::warn;
use native_windows_gui::{EmbedResource, Icon};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::sync::LazyLock;
use std::{error, fs};
use std::ops::Not;
use windows::{core::*, Win32::Media::Audio::*};

pub(crate) mod res_ids; /* autogenerated */

// #[macro_export]
// macro_rules! rs {
//     ($res_id:ident) => {
//         &RESOURCES.with(|r| r.string($res_id))
//     };
// }

// #[macro_export]
// macro_rules! rsf {
//     ($res_id:ident, $($arg:expr),* ) => {
//         &RESOURCES.with(|r|{
//             str_fmt(r.string($res_id), &[$($arg.to_string()),*])
//         })
//     };
// }

#[macro_export]
macro_rules! r_icon {
    ($res_id:ident) => {
        &RESOURCES.with(|r| r.icon($res_id))
    };
}

thread_local! {
    pub(crate) static RESOURCES: Resources = Resources::new();
}

pub(crate) static RES: LazyLock<Res> = LazyLock::new(|| Res::load("res\\resources.toml"));

pub(crate) struct Resources {
    embed: EmbedResource,
}

impl Resources {
    fn new() -> Self {
        Self {
            embed: EmbedResource::load(None).expect("Unable to load embedded resources"),
        }
    }

    pub(crate) fn icon(&self, res_id: usize) -> Icon {
        let mut icon = Icon::default();

        Icon::builder()
            .source_embed(Some(&self.embed))
            .source_embed_id(res_id)
            .strict(true)
            .size(Some((16, 16)))
            .build(&mut icon)
            .expect("Unable to load resource icon");

        icon
    }

    pub(crate) fn string(&self, res_id: usize) -> String {
        self.embed
            .string(res_id as u32)
            .expect("Unable to read resource string")
    }
}

#[derive(Debug)]
pub(crate) struct ResSound {
    filename: String,
    data: Vec<u8>,
}

impl ResSound {
    fn new(filename: String) -> ResSound {
        let data =
            fs::read(&filename).expect(format!("Unable to read sound file: {}", filename).as_str());
        Self { filename, data }
    }

    pub(crate) fn play(&self) {
        unsafe {
            if PlaySoundW(
                PCWSTR::from_raw(self.data.as_ptr() as _),
                None,
                SND_MEMORY | SND_SYNC,
            )
            .as_bool().not()
            {
                warn!("Unable to play sound");
            }
        }
    }
}

impl Serialize for ResSound {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.filename)
    }
}

impl<'de> Deserialize<'de> for ResSound {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        Ok(ResSound::new(String::deserialize(deserializer)?))
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct ResSounds {
    switch_profile: ResSound,
}

#[derive(Serialize, Deserialize)]
pub(crate) struct ResStrings {
    pub(crate) app_title: String,
    pub(crate) clear_log: String,
    pub(crate) enabled: String,
    pub(crate) exit: String,
    pub(crate) file: String,
    pub(crate) log: String,
    pub(crate) logging_enabled: String,
    pub(crate) open: String,
    pub(crate) layout: String,
    pub(crate) no_layout: String,
    pub(crate) no_profile: String,
    pub(crate) tray_tip: String,
    pub(crate) action: String,
    pub(crate) rule: String,
    pub(crate) modifiers: String,
    pub(crate) transition: String,
    pub(crate) auto_switch_layout: String,
    pub(crate) key: String,
    pub(crate) status: String,
    pub(crate) time: String,
    pub(crate) virtual_key: String,
    pub(crate) scan_code: String,
}

#[derive(Serialize, Deserialize)]
pub(crate) struct Res {
    pub(crate) strings: ResStrings,
    pub(crate) sounds: ResSounds,
}

impl Res {
    pub(crate) fn load(filename: &str) -> Self {
        fs::read_to_string(filename)
            .ok()
            .and_then(|text| toml::from_str(&text).ok())
            .expect("Unable to load resources")
    }
}

#[cfg(test)]
mod test {

    // #[test]
    // fn test_play_sound() {
    //     play_sound(SOUND_GAME_LOCK_OFF);
    // }

    use crate::res::res_ids::IDI_ICON_APP;
    use crate::res::{Res, RESOURCES};

    // #[test]
    // fn test_rs() {
    //     assert_eq!("Keympostor", rs!(IDS_APP_TITLE));
    // }

    #[test]
    fn test_r_icon() {
        assert_ne!(std::ptr::null_mut(), r_icon!(IDI_ICON_APP).handle);
    }

    #[test]
    fn test_load_res() {
        let res = Res::load("..\\run\\res\\resources.toml");
        assert_eq!("Keympostor", res.strings.app_title);

        let sound = res.sounds.switch_profile;
        sound.play();
        sound.play();
        sound.play();
        sound.play();
    }
}
